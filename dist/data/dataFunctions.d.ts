import { ProjectedPoint, ProjectedLine, ProjectedSummary, ProjectedBin, RawSummary, RawPoint, RawLine, LineTypeSettings, SummaryTypeSettings, GenericObject, ExtentType } from "../types/generalTypes";
declare type validStrFnTypes = boolean | string | number | GenericObject | GenericObject[] | RawPoint | RawPoint[];
export declare function stringToFn<StrFnType extends validStrFnTypes>(accessor?: ((args?: GenericObject, index?: number) => StrFnType) | string | StrFnType, defaultAccessor?: (arg?: GenericObject, i?: number) => StrFnType, raw?: boolean): (d?: GenericObject, i?: number) => StrFnType;
export declare function stringToArrayFn<StrFnType extends validStrFnTypes>(accessor?: ((arg?: GenericObject, index?: number) => StrFnType) | string | StrFnType | Array<((arg?: GenericObject, index?: number) => StrFnType) | string | StrFnType>, defaultAccessor?: (arg?: GenericObject, index?: number) => StrFnType, raw?: boolean): Array<(arg?: GenericObject, index?: number) => StrFnType>;
declare type CalculateDataTypes = {
    lineDataAccessor: Array<Function>;
    summaryDataAccessor: Array<Function>;
    summaryStyleFn: Function;
    summaryClassFn: Function;
    summaryRenderModeFn: Function;
    xAccessor: Array<Function>;
    yAccessor: Array<Function>;
    summaries?: Array<RawSummary>;
    points?: Array<RawPoint>;
    lines?: Array<RawLine>;
    lineType: LineTypeSettings;
    showLinePoints?: boolean | string;
    showSummaryPoints?: boolean;
    xExtent?: ExtentType;
    yExtent?: ExtentType;
    invertX?: boolean;
    invertY?: boolean;
    summaryType: SummaryTypeSettings;
    adjustedSize: Array<number>;
    chartSize: Array<number>;
    xScaleType: Function;
    yScaleType: Function;
    baseMarkProps?: object;
    margin: object;
    defined?: Function;
    annotations: object[];
    filterRenderedLines: (value: ProjectedLine, index: number, array: ProjectedLine[]) => any;
    filterRenderedSummaries: (value: ProjectedSummary, index: number, array: ProjectedSummary[]) => any;
    filterRenderedPoints: (value: ProjectedPoint | ProjectedBin | ProjectedSummary, index: number, array: (ProjectedPoint | ProjectedBin | ProjectedSummary)[]) => any;
};
export declare const calculateDataExtent: ({ lineDataAccessor, xAccessor, yAccessor, summaries, points, lines, lineType, showLinePoints, showSummaryPoints, xExtent, yExtent, invertX, invertY, summaryDataAccessor, summaryType, adjustedSize: size, margin, baseMarkProps, summaryStyleFn, summaryClassFn, summaryRenderModeFn, chartSize, filterRenderedLines, filterRenderedSummaries, filterRenderedPoints, defined, annotations }: CalculateDataTypes) => {
    xExtent: any[];
    yExtent: any[];
    projectedLines: ProjectedLine[];
    projectedPoints: ProjectedPoint[];
    projectedSummaries: ProjectedSummary[];
    fullDataset: (ProjectedPoint | ProjectedSummary | ProjectedBin)[];
    calculatedXExtent: any[];
    calculatedYExtent: any[];
};
export {};
